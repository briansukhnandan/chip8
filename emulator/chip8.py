import sys
import random
import pygame
import display as d

'''
How to run this program:
python3 chip8.py ROMs/Pong.ch8
'''

#######################CONSTANTS##################
NUM_REGISTERS = 0x10 # 16
MAX_MEMORY = 0x1000 # 4096
STACK_POINTER_START = 0x52
PROGRAM_COUNTER_START = 0x200 # PC starts at 512
REGISTER_BIT_LENGTH = 0x8

KEYBINDS = {
    0x1: pygame.K_1,
    0x2: pygame.K_2,
    0x3: pygame.K_3,
    0x4: pygame.K_4,
    0x5: pygame.K_q,
    0x6: pygame.K_w,
    0x7: pygame.K_e,
    0x8: pygame.K_r,
    0x9: pygame.K_a,
    0x0: pygame.K_s,
    0xA: pygame.K_d,
    0xB: pygame.K_f,
    0xC: pygame.K_z,
    0xD: pygame.K_x,
    0xE: pygame.K_c,
    0xF: pygame.K_v
}
##################################################

class CPU:
    def __init__(self, ROM_path, screen):

        '''Our .ch8 file.'''
        self.ROM = ROM_path

        '''Chip8 has 2 timers. They both count down at 60Hz until 0.'''
        self.timers = {
            'delay' : 0, # Intended to be used for timing events of games. Value can be set/read.
            'sound' : 0 # Used for sound effects. When value is nonzero, a beep is made.
        }

        '''
        There are 16 main registers going from V0-VF.
        Each register is 8 bits long.

        NOTE - Register VF sometimes doubles as a flag for certain
        instructions.
        '''
        self.V = [0] * NUM_REGISTERS

        '''8-bit stack pointer so we can keep track of the next thing on the stack to be popped.'''
        self.sp = STACK_POINTER_START

        '''8-bit program counter to keep track of current instruction.'''
        self.pc = PROGRAM_COUNTER_START

        '''A 16-bit index register used with several opcodes that involve memory operations.'''
        self.I = 0

        '''
        The memory for Chip8 is 4096 (0x1000) or 4kb.
        Python's bytearray function will correctly allocate the specified
        amount of memory for us.
        '''
        self.memory = bytearray(MAX_MEMORY)

        '''The current opcode to be executed.'''
        self.current_opcode = 0x0

        '''
        A random number which will be regenerated upon every 0xC opcode.

        NOTE - On real hardware, the random number generated is done on the fly
        when needed and is generated by the systems random entropic dataset.
        '''
        self.random_num = random.randint(0,255)

        '''Our pygame display initialized from another file.'''
        self.screen = screen

        self.is_running = True
        
        #####################
        #####################
        #####################
        self.load_rom_into_memory()

    '''If we ever needed to reset CPU back to original state, run this function.'''
    def restart_cpu(self):
        self.V = [0] * NUM_REGISTERS
        self.sp = STACK_POINTER_START
        self.pc = PROGRAM_COUNTER_START
        self.I = 0
        self.memory = bytearray(MAX_MEMORY)
        self.current_opcode = 0x0
        self.is_running = True

        self.timers = {
            'delay' : 0,
            'sound' : 0
        }

        self.load_rom_into_memory()
    
    '''Function to load rom from .ch8 file into memory.'''
    def load_rom_into_memory(self):
        print('Loading ROM into memory...')
        i = PROGRAM_COUNTER_START # All chip 8 roms will have pc set to 0x200.

        with open(self.ROM, "rb") as f:
            while True:
                byte = f.read(1) # Read one byte at a time and store into memory.
                if not byte: # Once we reach EOF.
                    break

                # Python 3 lets us write 1 byte at a time to memory.
                self.memory[i] = int.from_bytes(byte, "big", signed=False)
                i += 1

    '''Function to dump all register data to txt file for debug.'''
    def dump_registers(self):

        f = open("register_dump.txt", "a")

        f.write('\n')
        f.write('Opcode: '+str(hex(self.current_opcode)))
        f.write('\n\n')
        for i in range(NUM_REGISTERS):
            s = 'V'+str(i)+' -> '+str(hex(self.V[i]))+' | '
            f.write(s)

            if (i+1) % 4 == 0:
                f.write('\n')

        f.write('\n')
        f.write('pc -> '+str(hex(self.pc))+'\n')
        f.write('sp -> '+str(hex(self.sp))+'\n')
        f.write('I (addr register) -> '+str(hex(self.I))+'\n')
        f.write('\n--------------------------------------\n')

        f.close()

    '''To manage the state of whether or not CPU is running.'''
    def stop_CPU(self):
        self.is_running = False

    '''Updating timers means to decrement them. Do not decrement if <= 0'''
    def update_timers(self):

        if self.timers['delay'] > 0:
            self.timers['delay'] -= 1

        if self.timers['sound'] > 0:
            self.timers['sound'] -= 1


    '''#####################################################'''
    '''# ALL OPCODE RELATED IMPLEMENTATIONS ARE BELOW.     #'''
    '''# IN ORDER TO SEE WHICH OPCODES CALL THEM REFER TO  #'''
    '''# .execute_current_opcode() function.               #'''
    '''#####################################################'''


    '''Get current opcodes starting at PC and PC+1.'''
    def get_current_opcode(self):
        # Each indiv memory is 1 byte, i.e. 2 hex each.
        # Shift current pc over by 8 bits, then add next bit (pc+1).
        return ((self.memory[self.pc] << 8) + self.memory[self.pc+1])

    
    '''Our workflow function to execute the current opcode.'''
    def execute_current_opcode(self, debug_instruction=None):

        # Only for testing specific opcodes for debugging.
        if debug_instruction:
            self.current_opcode = debug_instruction
        else:
            self.current_opcode = self.get_current_opcode()
        
        # Only for debugging purposes, to see what opcode we are executing.
        print('Executing current opcode: 0x{}'.format( format(self.current_opcode, '04x') ))

        # Increment opcode before executing instruction in case
        # our next instr jumps to a diff address.
        # Each instruction is 2 bytes long so increment by 2.
        self.pc += 2

        # Then shift by 12 bits (3 hex) to the right to get MSB which is
        # our specified operation.
        operation = (self.current_opcode & 0xF000) >> 12

        ###########--OPCODE IMPLEMENTATIONS--##########
        if operation == 0x0:
            
            # 3 cases:
            # 0NNN - Not necessary for most ROMs, will NOT be implemented.
            # 00E0 - Clear display
            # 00EE - Return from Subroutine
            if self.current_opcode == 0x00E0:
                print('CLEARING SCREEN')
                self.clear_screen()

            if self.current_opcode == 0x00EE:
                print('RETURNING FROM SUBROUTINE')
                self.return_from_subroutine()

        elif operation == 0x1:
            print('JUMP {}, operation {}'.format(
                hex(self.current_opcode & 0x0FFF), 
                hex(self.current_opcode >> 12)
                )
            )
            self.jump_to_NNN()

        elif operation == 0x2:
            print('CALL {}, operation {}'.format(
                hex(self.current_opcode & 0x0FFF), 
                hex(self.current_opcode >> 12)
                )
            )
            self.call_subroutine_at_NNN()

        elif operation == 0x3:
            print('SKIP {}, operation {}'.format(
                hex(self.pc),
                hex(self.current_opcode >> 12)
                )
            )
            self.skip_Vx_equals_NN()

        elif operation == 0x4:
            print('SKIP {}, operation {}'.format(
                hex(self.pc),
                hex(self.current_opcode >> 12)
                )
            )
            self.skip_Vx_not_equals_NN()

        elif operation == 0x5:
            print('SKIP {}, operation {}'.format(
                hex(self.pc),
                hex(self.current_opcode >> 12)
                )
            )
            self.skip_Vx_equals_Vy()

        elif operation == 0x6:
            print('SET V{}->{}, operation {}'.format(
                ((self.current_opcode & 0x0F00) >> 8), 
                hex(self.current_opcode & 0x00FF), 
                hex(self.current_opcode >> 12)
                )
            )
            self.set_Vx_NN()

        elif operation == 0x7:
            print('ADD {}->V{}, operation {}'.format(
                hex(self.current_opcode & 0x00FF), 
                ((self.current_opcode & 0x0F00) >> 8), 
                hex(self.current_opcode >> 12)
                )
            )
            self.add_NN_Vx()

        elif operation == 0x8:

            # Grab least significant bit to differentiate between 0x8 opcodes.
            diff = self.current_opcode & 0x000F

            # 0x8XY0
            if diff == 0x0:
                print('SET V{} -> V{}'.format(
                    (self.current_opcode & 0x0F00) >> 8,
                    (self.current_opcode & 0x00F0) >> 4
                    )
                )
                self.set_Vx_Vy()

            # 0x8XY1
            elif diff == 0x1:
                print('SET V{} -> V{} OR V{}'.format(
                    (self.current_opcode & 0x0F00) >> 8,
                    (self.current_opcode & 0x0F00) >> 8,
                    (self.current_opcode & 0x00F0) >> 4
                    )
                )
                self.set_Vx_Vx_or_Vy()
            
            # 0x8XY2
            elif diff == 0x2:
                print('SET V{} -> V{} AND V{}'.format(
                    (self.current_opcode & 0x0F00) >> 8,
                    (self.current_opcode & 0x0F00) >> 8,
                    (self.current_opcode & 0x00F0) >> 4
                    )
                )
                self.set_Vx_Vx_and_Vy()

            # 0x8XY3
            elif diff == 0x3:
                print('SET V{} -> V{} XOR V{}'.format(
                    (self.current_opcode & 0x0F00) >> 8,
                    (self.current_opcode & 0x0F00) >> 8,
                    (self.current_opcode & 0x00F0) >> 4
                    )
                )
                self.set_Vx_Vx_xor_Vy()

            # 0x8XY4
            elif diff == 0x4:
                print('SET V{} -> V{} + V{}'.format(
                    (self.current_opcode & 0x0F00) >> 8,
                    (self.current_opcode & 0x0F00) >> 8,
                    (self.current_opcode & 0x00F0) >> 4
                    )
                )
                self.add_Vy_to_Vx()

            # 0x8XY5
            elif diff == 0x5:
                print('SET V{} -> V{} - V{}'.format(
                    (self.current_opcode & 0x0F00) >> 8,
                    (self.current_opcode & 0x0F00) >> 8,
                    (self.current_opcode & 0x00F0) >> 4
                    )
                )
                self.subtract_Vy_from_Vx()

            # 0x8XY6
            elif diff == 0x6:
                print('SHIFT V{} RIGHT 1'.format(
                    (self.current_opcode & 0x0F00) >> 8
                    )
                )           
                self.shift_Vx_right_1()

            # 0x8XY7
            elif diff == 0x7:
                print('SET V{} -> V{} - V{}'.format(
                    (self.current_opcode & 0x0F00) >> 8,
                    (self.current_opcode & 0x00F0) >> 4,
                    (self.current_opcode & 0x0F00) >> 8
                    )
                )
                self.set_Vx_Vy_minus_Vx()

            # 0x8XYE
            elif diff == 0xE:
                print('SHIFT V{} LEFT 1'.format(
                    (self.current_opcode & 0x0F00) >> 8
                    )
                )
                self.shift_Vx_left_1()

        elif operation == 0x9:
            print('SKIP {}, operation {}'.format(
                self.pc,
                hex(self.current_opcode >> 12)
                )
            )
            self.skip_Vx_not_equals_Vy()

        elif operation == 0xA:
            print('SET I -> {}, operation {}'.format(
                hex(self.current_opcode & 0x0FFF),
                hex(self.current_opcode >> 12)
                )
            )
            self.set_I_NNN()

        elif operation == 0xB:
            print('JUMP {}, operation {}'.format(
                hex(self.V[0] + (self.current_opcode & 0x0FFF)), 
                hex(self.current_opcode >> 12)
                )
            )
            self.jump_V0_plus_NNN()

        elif operation == 0xC:
            print('SET V{} -> {} AND {}'.format(
                (self.current_opcode & 0x0F00) >> 8,
                hex(self.random_num),
                hex(self.current_opcode & 0x00FF)
                )
            )
            self.set_Vx_rand_and_NN()

        elif operation == 0xD:
            print('DRAW PIXEL AT ({}, {})'.format(
                int(self.V[(self.current_opcode & 0x0F00) >> 8]),
                int(self.V[(self.current_opcode & 0x00F0) >> 4])
                )
            )
            self.draw_sprite_at_Vx_Vy()

        elif operation == 0xE:
            
            diff = self.current_opcode & 0x00FF

            # 0xEX9E
            if diff == 0x9E:
                print('SKIP NEXT IF KEY V{} PRESSED'.format(
                    (self.current_opcode & 0x0F00) >> 8
                    )
                )
                self.skip_if_key_Vx_pressed()

            # 0xEXA1
            elif diff == 0xA1:
                print('SKIP NEXT IF KEY V{} NOT PRESSED'.format(
                    (self.current_opcode & 0x0F00) >> 8
                    )
                )
                self.skip_if_key_Vx_not_pressed()

        elif operation == 0xF:
            
            diff = self.current_opcode & 0x00FF

            # 0xFX07
            if diff == 0x07:
                print('SET V{} -> DT, operation {}'.format(
                    (self.current_opcode & 0x0F00) >> 8,
                    self.timers['delay']
                    )
                )
                self.set_Vx_delay_timer()

            # 0xFX0A
            elif diff == 0x0A:
                print('V{} WAITING FOR KEY PRESS...'.format(
                    (self.current_opcode & 0x0F00) >> 8
                    )
                )
                self.store_key_press_in_Vx()

            # 0xFX15
            elif diff == 0x15:
                print('SET DT -> V{}, operation {}'.format(
                    self.timers['delay'],
                    (self.current_opcode & 0x0F00) >> 8
                    )
                )
                self.set_delay_timer_Vx()

            # 0xFX18
            elif diff == 0x18:
                print('SET ST -> V{}, operation {}'.format(
                    self.timers['sound'],
                    (self.current_opcode & 0x0F00) >> 8
                    )
                )
                self.set_sound_timer_Vx()

            elif diff == 0x1E:
                print('ADD V{} -> I, operation {}'.format(
                    hex((self.current_opcode & 0x0F00) >> 8), 
                    hex(self.current_opcode >> 12)
                    )
                )
                self.add_Vx_to_I()

            elif diff == 0x29:
                print('SET I SPRITE V{}'.format(
                    (self.current_opcode & 0x0F00) >> 8
                    )
                )
                self.set_I_sprite_Vx()

            elif diff == 0x33:
                print('SET BCD OF V{} IN MEM'.format(
                    (self.current_opcode & 0x0F00) >> 8
                    )
                )
                self.store_Vx_bcd_in_memory()

            elif diff == 0x55:
                print('STORE V0->V{} IN MEM'.format(
                    (self.current_opcode & 0x0F00) >> 8
                    )
                )
                self.store_V0_to_Vx_in_memory()

            elif diff == 0x65:
                print('FILL V0->V{} FROM MEM'.format(
                    (self.current_opcode & 0x0F00) >> 8
                    )
                )
                self.fill_V0_to_Vx_in_memory()

            # print('Opcode not implemented yet')

    #####################################################################

    # 0x1NNN
    def jump_to_NNN(self):
        # We can simply set our program counter to be
        # NNN, which is last 3 sig. digits of current opcode.
        self.pc = self.current_opcode & 0x0FFF

    # 0x2NNN
    def call_subroutine_at_NNN(self):
        
        # Save the current pc onto the stack, 2 bytes at a time.
        self.memory[self.sp] = self.pc & 0x00FF # First 2 LSB
        self.sp += 1 # Increment stack pointer
        self.memory[self.sp] = (self.pc & 0xFF00) >> 8 # First 2 MSB.
        self.sp += 1

        # Set pc to NNN.
        self.pc = self.current_opcode & 0x0FFF

    # 0x3XNN
    def skip_Vx_equals_NN(self):
        NN = self.current_opcode & 0x00FF
        x = (self.current_opcode & 0x0F00) >> 8

        # Skip next instruction by simply incrementing our program
        # counter to next instruction.
        if (self.V[x] == NN):
            self.pc += 2

    # 0x4XNN
    def skip_Vx_not_equals_NN(self):
        NN = self.current_opcode & 0x00FF
        x = (self.current_opcode & 0x0F00) >> 8

        # Skip next instruction by simply incrementing our program
        # counter to next instruction.
        if (self.V[x] != NN):
            self.pc += 2

    # 0x5XY0
    def skip_Vx_equals_Vy(self):
        x = (self.current_opcode & 0x0F00) >> 8
        y = (self.current_opcode & 0x00F0) >> 4

        if (self.V[x] == self.V[y]):
            self.pc += 2
        
    # 0x6XNN
    def set_Vx_NN(self):
        NN = self.current_opcode & 0x00FF
        x = (self.current_opcode & 0x0F00) >> 8

        self.V[x] = NN

    # 0x7XNN
    def add_NN_Vx(self):
        NN = self.current_opcode & 0x00FF
        x = (self.current_opcode & 0x0F00) >> 8

        # Since each register is 8 bit we must handle overflow.
        # i.e we cannot let the registers go over 255.
        t = self.V[x] + NN
        self.V[x] = t if t < (2**8) else t - (2**8)

    # 0x9XY0
    def skip_Vx_not_equals_Vy(self):
        x = (self.current_opcode & 0x0F00) >> 8
        y = (self.current_opcode & 0x00F0) >> 4

        if (self.V[x] != self.V[y]):
            self.pc += 2

    # 0xANNN
    def set_I_NNN(self):
        NNN = self.current_opcode & 0x0FFF
        self.I = NNN

    # 0xBNNN
    def jump_V0_plus_NNN(self):
        NNN = self.current_opcode & 0x0FFF
        self.pc = self.V[0] + NNN

    # 0xCXNN
    def set_Vx_rand_and_NN(self):
        x = (self.current_opcode & 0x0F00) >> 8
        NN = self.current_opcode & 0x00FF

        self.V[x] = self.random_num & NN

        # Regen random_num so next random number is different.
        self.random_num = random.randint(0,255)

    # 0xDXYN
    def draw_sprite_at_Vx_Vy(self):
        x = (self.current_opcode & 0x0F00) >> 8
        y = (self.current_opcode & 0x00F0) >> 4
        num_bytes = self.current_opcode & 0x000F

        x_pos = self.V[x]
        y_pos = self.V[y]

        self.V[0xF] = 0
        
        # We need to grab n bytes starting at self.I.
        for y_i in range(num_bytes):

            b = bin(self.memory[self.I + y_i])
            b = b[2:].zfill(8) # Ensure length is 8.

            # Make sure the sprite wraps around vertically.
            y_t = y_pos + y_i
            y_t = y_t % self.screen.height

            for x_i in range(0x8):

                x_t = x_pos + x_i
                x_t = x_t % self.screen.width

                # Get color so we can set Vf accordingly.
                color = int(b[x_i])
                current = self.screen.get_pixel_at_coordinate(x_t, y_t)
                
                # Pixels are XOR'd onto the screen, so if the
                # current pixel is on, we will set color to 0 (OFF state)
                # and draw over that spot with the off pixel color.
                if color == 1 and current == 1:
                    # If 0 set to 1, else leave at 1.
                    self.V[0xF] = self.V[0xF] | 1
                    color = 0

                elif color == 0 and current == 1:
                    color = 1

                self.screen.draw_single_pixel(x_t, y_t, color)

        self.screen.update()

    '''##############################'''
    '''# 0x8 opcode implementations #'''
    '''##############################'''


    # 0x8XY0
    def set_Vx_Vy(self):
        x = (self.current_opcode & 0x0F00) >> 8
        y = (self.current_opcode & 0x00F0) >> 4

        self.V[x] = self.V[y]

    # 0x8XY1
    def set_Vx_Vx_or_Vy(self):
        x = (self.current_opcode & 0x0F00) >> 8
        y = (self.current_opcode & 0x00F0) >> 4

        self.V[x] = self.V[x] | self.V[y]

    # 0x8XY2
    def set_Vx_Vx_and_Vy(self):
        x = (self.current_opcode & 0x0F00) >> 8
        y = (self.current_opcode & 0x00F0) >> 4

        self.V[x] = self.V[x] & self.V[y]

    # 0x8XY3
    def set_Vx_Vx_xor_Vy(self):
        x = (self.current_opcode & 0x0F00) >> 8
        y = (self.current_opcode & 0x00F0) >> 4

        self.V[x] = self.V[x] ^ self.V[y]

    # 0x8XY4
    def add_Vy_to_Vx(self):
        x = (self.current_opcode & 0x0F00) >> 8
        y = (self.current_opcode & 0x00F0) >> 4

        # We must check for overflow (carry) and set VF to 1 if so.
        # Else we can just leave it at 0.
        t = self.V[x] + self.V[y]

        if t > 255:
            self.V[x] = t - (2**8)
            self.V[0xF] = 1
        else:
            self.V[x] = t
            self.V[0xF] = 0

    # 0x8XY5
    def subtract_Vy_from_Vx(self):
        x = (self.current_opcode & 0x0F00) >> 8
        y = (self.current_opcode & 0x00F0) >> 4

        # If Vx > Vy, then VF is set to 1, otherwise 0. 
        # Then Vy is subtracted from Vx, and the results stored in Vx.
        # Account for overflow if Vx < Vy

        if self.V[x] > self.V[y]:
            self.V[0xF] = 1
            self.V[x] = self.V[x] - self.V[y]
        else:
            self.V[0xF] = 0
            self.V[x] = 2**8 + (self.V[x] - self.V[y])

    # 0x8XY6
    def shift_Vx_right_1(self):
        x = (self.current_opcode & 0x0F00) >> 8
        
        # If the least-significant bit of Vx is 1, then VF is set to 1, 
        # otherwise 0. Then Vx is divided by 2.
        lsb_Vx = self.V[x] & 0x1

        self.V[x] = self.V[x] >> 1
        self.V[0xF] = lsb_Vx

    # 0x8XY7
    def set_Vx_Vy_minus_Vx(self):
        x = (self.current_opcode & 0x0F00) >> 8
        y = (self.current_opcode & 0x00F0) >> 4

        if self.V[y] > self.V[x]:
            self.V[0xF] = 1
            self.V[x] = self.V[y] - self.V[x]
        else:
            self.V[0xF] = 0
            self.V[x] = 2**8 + (self.V[y] - self.V[x])

    # 0x8XYE
    def shift_Vx_left_1(self):
        x = (self.current_opcode & 0x0F00) >> 8

        # Helper functions to find MSB.
        def bitLen(value): # Gives the length of an unsigned value in bits
            length = 0
            while (value):
                value >>= 1
                length += 1
            return(length)

        def getMSB(value, size): # Gets the MSB of an unsigned value in a size-bit format
            length = bitLen(value)
            if(length == size):
                return 1
            else:
                return 0

        # If the most-significant bit of Vx is 1, then VF is set to 1, 
        # otherwise to 0. Then Vx is multiplied by 2.
        # msb_Vx = (self.V[x] & 0x80) >> 8
        msb_Vx = getMSB(self.V[x], REGISTER_BIT_LENGTH)

        self.V[x] = self.V[x] << 1
        self.V[0xF] = msb_Vx


    '''##############################'''
    '''# 0x0 opcode implementations #'''
    '''##############################'''
    

    # 0x00E0
    def clear_screen(self):
        self.screen.clear_screen()

    # 0x00EE
    def return_from_subroutine(self):

        # We basically must perform the opposite of 
        # 2NNN opcode. So decrement stack, set value stored
        # in stack to program counter, 2 bytes at a time.

        # Take current value and shift to left since we stored
        # it in stack with last 2 bits going first.

        self.sp -= 1
        self.pc = self.memory[self.sp] << 8 # format will be like 0xXX00
        self.sp -= 1
        self.pc = self.pc + self.memory[self.sp] # format will then be like 0xXXYY
    

    '''##############################'''
    '''# 0xE opcode implementations #'''
    '''##############################'''

    # 0xEX9E
    def skip_if_key_Vx_pressed(self):
        x = (self.current_opcode & 0x0F00) >> 8

        # Opcode assumes the value of a keypress is stored in V[x]
        selected_key = self.V[x]

        # User will press and we will compare this with selected_key.
        currently_pressed_key = pygame.key.get_pressed()

        # Check if selected_key value is 1 in currently_pressed_key.
        # If return 1, then same key as Vx is pressed.
        if currently_pressed_key[KEYBINDS[selected_key]]:
            self.pc += 2

    # 0xEXA1
    def skip_if_key_Vx_not_pressed(self):
        x = (self.current_opcode & 0x0F00) >> 8

        # Opcode assumes the value of a keypress is stored in V[x]
        selected_key = self.V[x]

        # User will press and we will compare this with selected_key.
        currently_pressed_key = pygame.key.get_pressed()

        if not currently_pressed_key[KEYBINDS[selected_key]]:
            self.pc += 2
    

    '''##############################'''
    '''# 0xF opcode implementations #'''
    '''##############################'''


    # 0xFX07
    def set_Vx_delay_timer(self):
        x = (self.current_opcode & 0x0F00) >> 8
        self.V[x] = self.timers['delay']

    # 0xFX0A
    def store_key_press_in_Vx(self):
        x = (self.current_opcode & 0x0F00) >> 8

        # The following is a blocking operation. We need to wait
        # for a keypress for the execution to resume.
        input_received = False

        # While the user has not pressed a key yet.
        while not input_received:
            e = pygame.event.wait()

            if e.type == pygame.KEYDOWN:
                pressed_key = pygame.key.get_pressed()

                # Now loop over our KEYBINDS dict, and if the value
                # equals the true value in pressed_key, set Vx to the
                # key of that value.
                for k, v in KEYBINDS.items():
                    # if the current value is True in pressed_key array.
                    if pressed_key[v]:
                        self.V[x] = k
                        input_received = True

                        break

    # 0xFX15
    def set_delay_timer_Vx(self):
        x = (self.current_opcode & 0x0F00) >> 8
        self.timers['delay'] = self.V[x]

    # 0xFX18
    def set_sound_timer_Vx(self):
        x = (self.current_opcode & 0x0F00) >> 8
        self.timers['sound'] = self.V[x]

    # 0xFX1E
    def add_Vx_to_I(self):
        x = (self.current_opcode & 0x0F00) >> 8
        self.I += self.V[x]

    # 0xFX29
    def set_I_sprite_Vx(self):
        # Each sprite is 5 bytes long in chip8.
        x = (self.current_opcode & 0x0F00) >> 8
        self.I = self.V[x] * 5

    # 0xFX33
    def store_Vx_bcd_in_memory(self):

        x = (self.current_opcode & 0x0F00) >> 8

        def BCD(v):
            ones = int(v % 10)
            tens = int((v / 10) % 10)
            hundreds = int((v / 100) % 10)

            return [hundreds, tens, ones]

        bcd = BCD(self.V[x])

        self.memory[self.I] = bcd[0] # Hundreds at memory location I
        self.memory[self.I + 1] = bcd[1] # Tens at mem I+1
        self.memory[self.I + 2] = bcd[2] # Ones at mem I+2

    # 0xFX55
    def store_V0_to_Vx_in_memory(self):
        x = (self.current_opcode & 0x0F00) >> 8

        # Vx is inclusive in this loop, so we need to do range(x+1).
        # Registers are stored starting at I and incremented by 1.
        for i in range(x+1):
            self.memory[self.I + i] = self.V[i]

    # 0xFX65
    def fill_V0_to_Vx_in_memory(self):
        x = (self.current_opcode & 0x0F00) >> 8

        # Vx is inclusive in this loop, so we need to do range(x+1).
        # Registers are stored starting at I and incremented by 1.
        for i in range(x+1):
            self.V[i] = self.memory[self.I + i]


    '''######################'''
    '''# CPU cycle function #'''
    '''######################'''


    def cycle(self, debug_instruction=None):
        self.execute_current_opcode(debug_instruction)
